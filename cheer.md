# HTML

#### 1、块元素和行内元素区别是什么？常见块元素和行内元素有哪些？

块元素的特点：

- 独占一行，不能与其他元素并排显示。
- 可以设置宽度、高度、边框、内边距和外边距。
- 默认宽度为父元素的100%。
- 默认高度为子元素的总高度。

行内元素的特点是：

- 可以与其他行内元素或行内块元素并排显示，不会换行。
- 不能设置宽度、高度、上下边框和上下内边距。
- 默认宽度为内容的宽度。
- 默认高度为一行的高度。

行内块元素的特点是：

- 可以与其他行内元素或行内块元素在一行显示，但是之间会有空白缝隙。设置它上一级的`font-size`为0，才会消除缝隙。
- 可以设置宽度、高度、边框、内边距和外边距。
- 默认宽度为内容的宽度，不会自动填满父元素的宽度。
- 默认高度为内容的高度，不会自动撑开父元素的高度。

常见的块元素：`div p h1-h6 ul ol li`

常见的行内元素：`span a label`

常见的行内块元素：`button img input select textarea`



#### 2、简述一下你对HTML语义化的理解？

HTML语义化：就是页面去掉样式或者加载失败的时候能够让页面呈现出清晰的结构。在写页面的时候，我们可以直接引用语义化标签，不需要再使用没有任何含义的`div`标签。语义化标签对于机器来说可以识别，对于开发人员来说很容易明白。



HTML5新增的语义化标签：`header nav aside main footer section article menu`



语义化的好处：

- 有利于SEO：语义化标签使搜索引擎更好的理解网页内容，提高网页在搜索结果中的排名。
- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义化的方式来渲染网页。
- 方便项目的开发及维护，使HTML代码更具有可读性。



#### 3、HTML的字符实体是什么？

1. 介绍概念和作用
   - HTML字符实体是一种用来替换HTML中预留或者无法直接输入的字符的编码方式。
2. 说明HTML的字符实体的组成部分
   - 它由一个和号`&`和一个实体名称，以及一个分号`;`组成。
   - 或者是由一个和号`&`，一个井号`#`，一个实体编号，以及一个分号`;`组成。
   - 空格：`&nbsp;`或`&#160;`
   - 版权符号：`&copy;`或`&#169;`
3. 总结优缺点
   - HTML字符实体可以避免浏览器误解预留字符或者显示特殊符号，但是它也增加了代码的长度和复杂度。



#### 4、回流和重绘？

回流和重绘是浏览器渲染页面时的两个过程，它们都会影响页面的性能和用户体验，所以我们应该尽量避免或者减少它们的发生。

回流是当页面中的元素发生了几何属性（如宽度、高度、位置等）的变化，导致浏览器需要重新计算元素的布局，更新渲染树，并重新绘制元素的过程。回流会影响到渲染树中的所有节点，所以它是一个比较耗费性能的过程。

重绘是当页面中的元素发生了视觉属性（如颜色、背景、边框等）的变化，但不影响布局时，浏览器只需要重新绘制元素，而不需要重新计算布局的过程。重绘只影响到渲染树中的部分节点，所以它比回流更轻量级。

回流和重绘的区别就是页面布局是否改变。回流一定会触发重绘，而重绘不一定会触发回流。

一些常见的导致回流和重绘的操作有：

- 改变元素的大小、位置、边距、内边距、边框等会导致回流。
- 改变元素的颜色、背景、字体等会导致重绘。
- 添加或者删除可见的DOM节点会导致回流。
- 激活CSS伪类（如`:hover`）会导致重绘或者回流。
- 获取一些布局信息（如offset系列，scroll系列，client系列）会导致强制回流。

为了优化页面的渲染性能，可以采用以下一些方法：

- 批量修改样式，比如使用class来一次性修改多个样式属性，而不是逐个修改。
- 使用`transform`、`opacity`、`filter`等属性来实现动画效果，而不是使用`left`、`top`、`width`等属性。
- 使用文档碎片或者离线DOM来批量操作节点，比如先将节点隐藏或者移出文档流，然后进行多次修改，最后再显示或者插入到文档流中。
- 避免使用`table`布局，因为表格中的一个单元格变化会导致整个表格的回流。
- 避免使用强制回流的属性或方法，比如`offsetWidth`、`offsetHeight`等，因为它们会让浏览器立即执行队列中的所有回流操作。



题外内容：

- 文档碎片
  - 文档碎片的使用方法如下：

    - 使用`document.createDocumentFragment()`方法创建一个空白的文档碎片对象。
    - 使用`appendChild()`方法将需要插入的DOM节点添加到文档碎片中。
    - 使用`appendChild()`方法将文档碎片插入到目标节点中。

  - 代码举例：

    ```javascript
    // 获取 ul 节点
    var ul = document.querySelector("ul");
    // 创建文档碎片
    var fragment = document.createDocumentFragment();
    // 循环创建 100 个 li 节点，并添加到文档碎片中
    for (var i = 0; i < 100; i++) {
      var li = document.createElement("li");
      li.textContent = i + 1;
      fragment.appendChild(li);
    }
    // 将文档碎片插入到 ul 节点中
    ul.appendChild(fragment);
    ```

  - 好处：

    - 这样只会触发一次回流和重绘，而不是每次插入一个节点就触发一次。

- 离线DOM

  - 可以通过设置元素属性`display:none`，将其从页面上去掉，然后进行后续操作，这些后续操作也不会触发回流和重绘，这个过程称为离线操作。

  - 代码举例：

    ```javascript
    let container = document.getElementById('container')
    container.style.display = 'none'
    container.style.width = '100px'
    container.style.height = '200px'
    container.style.border = '10px solid red'
    container.style.color = 'red'
    ...（省略了许多类似的后续操作）
    container.style.display = 'block'
    ```

    

#### 5、浏览器解析渲染机制？

浏览器解析渲染机制是指浏览器如何将接收到的HTML、CSS、JavaScript等文件转换为用户可以看到和交互的网页的过程。大致可以分为以下几个步骤：

1. 构建DOM树。浏览器会自上而下地解析HTML文件，将标签、文本、注释等转换为DOM节点，并按照层级关系构建成一棵DOM树。
2. 构建CSSOM树。浏览器会解析CSS文件，将选择器、属性、值等转换为CSSOM节点，并按照层级关系构建成一棵CSSOM树。
3. 生成渲染树。浏览器会将DOM树和CSSOM树合并，生成一棵渲染树，渲染树上地每个节点都包含了元素地内容和样式信息。
4. 布局渲染树。浏览器会根据渲染树上地信息，计算出每个节点在视口中的位置和大小，这个过程叫做布局或者回流。
5. 绘制渲染树。浏览器会根据布局得到的结果，将渲染树上的每个节点绘制到屏幕上，这个过程叫做绘制或者重绘。

在这个过程中，如果HTML、CSS或者JavaScript文件发生了变化，可能会导致渲染树、布局或者绘制的更新，这些更新会影响页面的性能和用户体验，所以我们应该尽量减少不必要的更新，优化页面的解析渲染机制。



题外内容：

![浏览器解析渲染机制.png](D:\qiahua\interview\images\浏览器解析渲染机制.png)

- 解析HTML，生成DOM树；解析CSS，生成CSSOM树。
- 将DOM树和CSSOM树结合，生成渲染树。
- Layout(回流)：根据生成的渲染树，进行回流，得到节点的几何信息。
- Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
- Display：将像素发送给GPU，展示在页面上。



# CSS

#### 1、讲一下盒模型，普通盒模型和怪异盒模型有什么区别？

盒模型是指在网页设计中，每个元素都被视为一个拥有宽度、高度、边框、内边距和外边距的矩形盒子。盒模型分为两种：**标准盒模型**和**怪异盒模型**。



标准盒模型的元素宽度和高度由**内容区域、边框、内边距和外边距**四个部分组成。

标准盒宽度和高度计算公式：

- 总宽度 = 内容区域宽度 + 左右边框 + 左右内边距 + 左右外边距
- 总高度 = 内容区域高度 + 上下边框 + 上下内边距 + 上下外边距



怪异盒模型的元素宽度和高度由**内容区域，边框**两个部分组成。

怪异盒宽度和高度计算公式：

- 总宽度 = 内容区域宽度 + 左右边框
- 总高度 = 内容区域高度 + 上下边框



#### 2、伪类和伪元素的区别是什么？

伪类是用来选择处于特定状态的元素，比如`:hover`，`:active`等。

伪元素是用来创造虚构的元素，比如`::before`，`::after`等。

伪类不会创造新的元素，而伪元素会。

伪类以单冒号(:)开头，而伪元素以双冒号(::)开头。



#### 3、CSS如何实现居中布局？

水平居中：

- 行内元素居中：
  - 父元素设置`text-align:center;`
- 块级元素居中：
  - 指定宽度后，设置`margin:0 auto;`

垂直居中：

- 行内元素居中：
  - 设置`line-height`与`height`相等。

- 块级元素居中：

  - 使用`flex`布局
  - 在已知高度的情况下：
    - 第一种：使用CSS3的新属性`calc`，计算`top`：`top: calc(50% - 50px)`
      - 请注意calc属性计算时运算符前后有空格。
    - 第二种：使用`top` + `margin-top`实现
  - 在未知高度的情况下：
  - 使用`margin-top:50%` + `transform:translateY(-50%)`
  



#### 4、CSS的选择器有哪些？

- ID选择器 `#hello`
- 类选择器 `.container`
- 标签选择器 `div`
- 后代选择器 `h1 p`
- 相邻后代选择器 `h1>p`
- 兄弟选择器 `li~a`
- 相邻兄弟选择器 `li+a`
- 属性选择器 `input[type="text"]`
- 伪类选择器 `a:hover`
- 伪元素选择器 `::before`
- 通配符选择器 `*`



#### 5、CSS优先级如何计算？

CSS优先级计算是指多个CSS声明作用于同一个元素时，如何确定哪个声明的效果最终生效。

CSS优先级计算的基本原则是：

- 优先级由选择器的类型和数量决定，一般来说，内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 > 通配符选择器。
- 优先级可以用四个数字（a,b,c,d）表示，其中a表示内联样式的个数，b表示ID选择器的个数，c表示类选择器、属性选择器和伪类选择器的个数之和，d表示标签选择器和伪元素选择器的个数之和。比较优先级时，按照a,b,c,d的顺序依次比较，大的则优先级高，相等则比较下一个。
- 如果两个声明的优先级相同，则后出现的声明会覆盖前面的声明。
- 如果一个声明中使用了 `!important` 标志，则该声明的优先级最高，除非另一个声明也使用了 `!important` 并且优先级更高或者出现在后面。
- 优先级只与选择器有关，与选择器在文档的位置或者样式表中的位置无关。

举例：

```html
<style>
  <!-- 权重：0101 -->
  <!-- 权重最高 -->
  #container p {
    color: red;
  }
  <!-- 权重：0010 -->
  .box {
    color: green;
  }
  <!-- 权重：0001 -->
  p {
    color: blue !important;
  }
</style>
<div id="container">
  <p class="box">Hello</p>
</div>
```



#### 6、长度单位px，em和rem的区别是什么？

px时相对于屏幕分辨率的长度单位。px的有点是精确和一致，缺点是不灵活，不能自适应不同设备的屏幕尺寸和分辨率。

em是相对于当前元素的字体大小的长度单位，1em等于当前元素的`font-size`。如果当前元素没有设置`font-size`，则会继承父元素的`font-size`。em的优点是可以实现元素内部的缩放效果，缺点是计算复杂，容易受到父元素的影响。

rem是相对于根元素(html)的字体大小的长度单位，1rem等于html元素的`font-size`。如果html元素没有设置`font-size`，则会使用浏览器的默认字体大小(通常是16px)。rem的优点是可以实现整个页面的缩放效果，且计算简单，不受父元素的影响，缺点是兼容性不如px和em。



#### 7、讲一下flex弹性盒布局？

1. 概念和优势
   - flex布局是一种用于按行或列布局元素的一维布局方法，它可以为盒状模型提供最大的灵活性，可以方便地实现各种对齐、分布、缩放等效果。
2. 核心属性
   - flex布局主要有以下几个属性：
     - `display`用于指定一个容器为flex布局
     - `flex-direction`用于指定主轴的方向
     - `justify-content`用于指定主轴的对齐方式
     - `align-items`用于指定交叉轴的对齐方式
     - `flex-wrap`用于指定是否换行
3. 总结flex布局的特点和优缺点
   - 总之，flex布局是一种非常灵活和强大的布局方法，它可以适应不同的屏幕尺寸和设备，也可以简化很多复杂的布局问题。但是，它也有一些缺点，比如兼容性问题，需要使用浏览器前缀或者polyfill来支持老旧的浏览器；还有性能问题，如果项目过多或者嵌套过深，可能会影响渲染速度和内存消耗。



#### 8、浮动塌陷问题的解决方法是什么？

1. 介绍浮动塌陷的概念和原因
   - 浮动塌陷是指当一个容器的子元素浮动后，导致容器的高度丢失或者缩小，从而影响布局的现象。这是因为浮动元素脱离了文档流，不占据容器的空间，而容器的高度默认是由子元素撑开的。
2. 列举浮动塌陷的几种解决方法
   - 给容器设置固定的高度，这样就不依赖子元素的高度了。但这样做需要知道容器的精确高度，而且不利于响应式布局。
   - 给容器设置`overflow`属性为`hidden`或者`auto`，这样可以触发BFC(块级格式化上下文)，让容器包含浮动元素。但这样做可能会导致内容溢出或者出现滚动条。
   - 给容器添加一个空元素，并给它设置`clear`属性为`both`，这样就可以清除浮动，让容器恢复正常高度。但这样做需要增加额外的标签和样式。
   - 使用**伪元素**在容器的最后添加一个**内容为空**的**块级元素**，并给它设置`clean`属性为`both`，这样也可以清除浮动，而且不需要增加额外的标签和样式。



#### 9、讲一下position的属性值的含义？

1. 介绍`position`属性的概念和作用
   - `postion`是CSS中用来控制元素定位方式的一个属性，它可以让元素按照文档流或者相对于其他元素进行偏移或者固定。
2. 列举`position`属性
   - `postion`由5个值，分别是`static`、`relative`、`absolute`、`fixed`和`sticky`，它们决定了元素是按照文档流还是脱离文档流进行定位，以及相对于哪个参考点进行偏移或者固定。
     - `static`是默认值，表示元素按照文档流进行定位，不受其他定位属性的影响。
     - `relative`表示元素按照文档流进行定位，然后相对于自身进行偏移，偏移不会影响其他元素的位置。
     - `absolute`表示元素脱离文档流，相对于最近的定位祖先元素或者初始包含块进行定位，元素的位置由其他定位属性确定。
     - `fixed`表示元素脱离文档流，相对于视口进行定位，元素的位置由其他定位属性确定，元素在页面滚动时不会改变位置。
     - `sticky`表示元素按照文档流进行定位，然后在其最近滚动祖先和其包含块之间切换相对定位和固定定位，实现“粘性”效果。



#### 10、position:fixed一定是相对于浏览器窗口进行定位吗？

1. 介绍`position:fiexd`

   - `position:fiexd`通常是相对于浏览器窗口进行定位的，这意味着它不随滚动条滚动，而是始终保持在某个位置不动。

2. 说明`position:fiexd`属性的特殊规则

   - 但是，如果`position:fixed`元素的祖先元素具有某些CSS属性，那么`position:fixed`元素就不再相对于浏览器窗口进行定位，而是相对于祖先元素进行定位。这些属性包括`transform`、filter、perspective、contain、mix-blend-mode等。

3. 总结

   - 这些CSS属性会使祖先元素成为`position:fixed`元素的包含块，也就是`position:fixed`元素的定位参考点。这样`position:fixed`元素就会随着祖先元素的滚动而滚动，并且受到祖先元素的大小和位置的影响。

4. 示例代码

   ```html
   <html>
       <head>
           <style>
               * {
                   margin: 0;
                   padding: 0;
                   box-sizing: border-box;
               }
   
               .container {
                   height: 2000px;
               }
   
               #b1 {
                   height: 400px;
                   background-color: aqua;
               }
   
               #b2 {
                   height: 800px;
                   background-color: red;
                   /* 切换这个属性即可验证 */
                   transform: scale(1);
               }
   
               .ad {
                   position: fixed;
                   top: 50%;
                   transform: translateY(-50%);
                   width: 200px;
                   height: 300px;
                   background-color: #73ad21;
               }
           </style>
       </head>
       <body>
           <div class="container">
               <div id="b1"></div>
               <div id="b2">
                   <div class="ad"></div>
               </div>
           </div>
       </body>
   </html>
   ```



#### 11、BFC和IFC？

BFC和IFC是CSS布局中的两种格式化上下文，它们是一种独立的渲染区域，有自己的布局规则，可以与其他格式化上下文相互隔离。

BFC是块级格式化上下文，它是由块级盒子组成的 ，比如`div p ul`等元素。BFC的布局规则如下：

- BFC中的元素按照垂直方向从上到下排列，相邻元素的外边距会发生重叠。
- BFC中的元素不会影响或者被影响到外部的元素，也就是说BFC是一个独立的容器。
- BFC的宽度由包含块的宽度和浮动元素决定，也就是说BFC可以包含浮动元素，并防止浮动元素溢出。
- BFC可以组织元素被父元素的边距折叠。

BFC可以通过以下方式触发：

- 根元素（整个页面就是一个大的BFC）
- float 为 left | right
- overflow 为 hidden | auto | scroll
- display 为 inline-block | table-cell | table-caption | flex | inline-flex
- position 为 absolute | fixed

BFC的功能：

- 解决margin塌陷
- 清除浮动
- 防止普通文档流被浮动元素遮挡

IFC是行内格式化上下文，它是由行内盒子组成的，比如`span a img`等元素，IFC的布局规则如下：

- IFC中的元素按照水平方向从左到右排列，相邻元素的外边距不会发生重叠。
- IFC中的元素会根据垂直对齐方式（vertical-align）进行对齐，可以是顶部对齐、底部对齐、居中对齐等。
- IFC中的元素不会影响或者被影响到外部的元素，也就是说IFC是一个独立的容器。
- ICC的高度由包含块的高度和行框决定，也就是说IFC可以包含多行文本，并根据行高进行换行。

IFC可以通过以下方式触发：

- display 为 inline | inline-block



题外内容：

[深度剖析Margin塌陷，BFC，Containing Block之间的关系](https://zhuanlan.zhihu.com/p/30168984)



# Vue

#### 1、讲一下computed和watch的区别？

1. 介绍概念和作用
   - `computed`是计算属性，用来根据现有的属性计算出一个新的属性。
   - `watch`是监听，用来监听`data`中的数据变化，并执行相应的回调函数。
2. 列举核心区别
   - `computed`支持缓存，当其依赖的属性没有发生变化时，计算属性会从缓存中读取，而不会重新计算；`watch`不支持缓存，当监听的属性发生变化时，每次都会执行回调函数。
   - `computed`适用于根据其他属性的变化而变化的场景，比如购物车商品结算；`watch`适用于根据数据变化而执行异步操作或开销较大的操作的场景，比如搜索框根据关键词发送请求。
   - `computed`只能返回一个值，不能执行其他操作；`watch`可以返回任意值或执行任意操作。
   - `computed`默认只有`getter`方法，如果需要`setter`方法，需要手动设置；`watch`默认由`handler`方法，可以设置`deep`、`immediete`等选项。



#### 2、v-if和v-show的区别？

1. 介绍概念和作用
   - `v-if`和`v-show`都是Vue中的指令，用来控制元素的显示和隐藏。
2. 列举核心区别
   - `v-if`是根据条件来动态地增加或删除DOM元素，只有当条件为真时才会渲染元素；`v-show`是根据条件来动态地显示或隐藏元素，无论条件是否为真，元素都会被渲染，只是通过CSS的`display`属性来控制显隐。
   - `v-if`有更高的切换开销，因为每次切换都会触发元素的销毁和重建；`v-show`有更高的初始渲染开销，因为无论条件是否为真，元素都会被渲染。
   - `v-if`支持`template`标签，可以在一个条件块中包含多个元素；`v-show`不支持`template`标签，只能作用于单个元素。
   - `v-if`搭配`v-else`可以实现多分支的条件渲染；`v-show`没有类似指令，只能实现单分支的条件渲染。