# HTML

## 1、块元素和行内元素区别是什么？常见块元素和行内元素有哪些？

块元素的特点：

- 独占一行，不能与其他元素并排显示。
- 可以设置宽度、高度、边框、内边距和外边距。
- 默认宽度为父元素的100%。
- 默认高度为子元素的总高度。

行内元素的特点是：

- 可以与其他行内元素或行内块元素并排显示，不会换行。
- 不能设置宽度、高度、上下边框和上下内边距。
- 默认宽度为内容的宽度。
- 默认高度为一行的高度。

行内块元素的特点是：

- 可以与其他行内元素或行内块元素在一行显示，但是之间会有空白缝隙。设置它上一级的`font-size`为0，才会消除缝隙。
- 可以设置宽度、高度、边框、内边距和外边距。
- 默认宽度为内容的宽度，不会自动填满父元素的宽度。
- 默认高度为内容的高度，不会自动撑开父元素的高度。

常见的块元素：`div p h1-h6 ul ol li`

常见的行内元素：`span a label`

常见的行内块元素：`button img input select textarea`



## 2、简述一下你对HTML语义化的理解？

HTML语义化：就是页面去掉样式或者加载失败的时候能够让页面呈现出清晰的结构。在写页面的时候，我们可以直接引用语义化标签，不需要再使用没有任何含义的`div`标签。语义化标签对于机器来说可以识别，对于开发人员来说很容易明白。



HTML5新增的语义化标签：`header nav aside main footer section article menu`



语义化的好处：

- 有利于SEO：语义化标签使搜索引擎更好的理解网页内容，提高网页在搜索结果中的排名。
- 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义化的方式来渲染网页。
- 方便项目的开发及维护，使HTML代码更具有可读性。



## 3、HTML的字符实体是什么？

1. 介绍概念和作用
   - HTML字符实体是一种用来替换HTML中预留或者无法直接输入的字符的编码方式。
2. 说明HTML的字符实体的组成部分
   - 它由一个和号`&`和一个实体名称，以及一个分号`;`组成。
   - 或者是由一个和号`&`，一个井号`#`，一个实体编号，以及一个分号`;`组成。
   - 空格：`&nbsp;`或`&#160;`
   - 版权符号：`&copy;`或`&#169;`
3. 总结优缺点
   - HTML字符实体可以避免浏览器误解预留字符或者显示特殊符号，但是它也增加了代码的长度和复杂度。



## 4、回流和重绘？

回流和重绘是浏览器渲染页面时的两个过程，它们都会影响页面的性能和用户体验，所以我们应该尽量避免或者减少它们的发生。

回流是当页面中的元素发生了几何属性（如宽度、高度、位置等）的变化，导致浏览器需要重新计算元素的布局，更新渲染树，并重新绘制元素的过程。回流会影响到渲染树中的所有节点，所以它是一个比较耗费性能的过程。

重绘是当页面中的元素发生了视觉属性（如颜色、背景、边框等）的变化，但不影响布局时，浏览器只需要重新绘制元素，而不需要重新计算布局的过程。重绘只影响到渲染树中的部分节点，所以它比回流更轻量级。

回流和重绘的区别就是页面布局是否改变。回流一定会触发重绘，而重绘不一定会触发回流。

一些常见的导致回流和重绘的操作有：

- 改变元素的大小、位置、边距、内边距、边框等会导致回流。
- 改变元素的颜色、背景、字体等会导致重绘。
- 添加或者删除可见的DOM节点会导致回流。
- 激活CSS伪类（如`:hover`）会导致重绘或者回流。
- 获取一些布局信息（如offset系列，scroll系列，client系列）会导致强制回流。

为了优化页面的渲染性能，可以采用以下一些方法：

- 批量修改样式，比如使用class来一次性修改多个样式属性，而不是逐个修改。
- 使用`transform`、`opacity`、`filter`等属性来实现动画效果，而不是使用`left`、`top`、`width`等属性。
- 使用文档碎片或者离线DOM来批量操作节点，比如先将节点隐藏或者移出文档流，然后进行多次修改，最后再显示或者插入到文档流中。
- 避免使用`table`布局，因为表格中的一个单元格变化会导致整个表格的回流。
- 避免使用强制回流的属性或方法，比如`offsetWidth`、`offsetHeight`等，因为它们会让浏览器立即执行队列中的所有回流操作。



题外内容：

- 文档碎片
  - 文档碎片的使用方法如下：

    - 使用`document.createDocumentFragment()`方法创建一个空白的文档碎片对象。
    - 使用`appendChild()`方法将需要插入的DOM节点添加到文档碎片中。
    - 使用`appendChild()`方法将文档碎片插入到目标节点中。

  - 代码举例：

    ```javascript
    // 获取 ul 节点
    var ul = document.querySelector("ul");
    // 创建文档碎片
    var fragment = document.createDocumentFragment();
    // 循环创建 100 个 li 节点，并添加到文档碎片中
    for (var i = 0; i < 100; i++) {
      var li = document.createElement("li");
      li.textContent = i + 1;
      fragment.appendChild(li);
    }
    // 将文档碎片插入到 ul 节点中
    ul.appendChild(fragment);
    ```

  - 好处：

    - 这样只会触发一次回流和重绘，而不是每次插入一个节点就触发一次。

- 离线DOM

  - 可以通过设置元素属性`display:none`，将其从页面上去掉，然后进行后续操作，这些后续操作也不会触发回流和重绘，这个过程称为离线操作。

  - 代码举例：

    ```javascript
    let container = document.getElementById('container')
    container.style.display = 'none'
    container.style.width = '100px'
    container.style.height = '200px'
    container.style.border = '10px solid red'
    container.style.color = 'red'
    ...（省略了许多类似的后续操作）
    container.style.display = 'block'
    ```

    

## 5、浏览器解析渲染机制？

浏览器解析渲染机制是指浏览器如何将接收到的HTML、CSS、JavaScript等文件转换为用户可以看到和交互的网页的过程。大致可以分为以下几个步骤：

1. 构建DOM树。浏览器会自上而下地解析HTML文件，将标签、文本、注释等转换为DOM节点，并按照层级关系构建成一棵DOM树。
2. 构建CSSOM树。浏览器会解析CSS文件，将选择器、属性、值等转换为CSSOM节点，并按照层级关系构建成一棵CSSOM树。
3. 生成渲染树。浏览器会将DOM树和CSSOM树合并，生成一棵渲染树，渲染树上地每个节点都包含了元素地内容和样式信息。
4. 布局渲染树。浏览器会根据渲染树上地信息，计算出每个节点在视口中的位置和大小，这个过程叫做布局或者回流。
5. 绘制渲染树。浏览器会根据布局得到的结果，将渲染树上的每个节点绘制到屏幕上，这个过程叫做绘制或者重绘。

在这个过程中，如果HTML、CSS或者JavaScript文件发生了变化，可能会导致渲染树、布局或者绘制的更新，这些更新会影响页面的性能和用户体验，所以我们应该尽量减少不必要的更新，优化页面的解析渲染机制。



题外内容：

![浏览器解析渲染机制.png](images/浏览器解析渲染机制.png)

- 解析HTML，生成DOM树；解析CSS，生成CSSOM树。
- 将DOM树和CSSOM树结合，生成渲染树。
- Layout(回流)：根据生成的渲染树，进行回流，得到节点的几何信息。
- Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
- Display：将像素发送给GPU，展示在页面上。



# CSS

## 1、讲一下盒模型，普通盒模型和怪异盒模型有什么区别？

盒模型是指在网页设计中，每个元素都被视为一个拥有宽度、高度、边框、内边距和外边距的矩形盒子。盒模型分为两种：**标准盒模型**和**怪异盒模型**。



标准盒模型的元素宽度和高度由**内容区域、边框、内边距和外边距**四个部分组成。

标准盒宽度和高度计算公式：

- 总宽度 = 内容区域宽度 + 左右边框 + 左右内边距 + 左右外边距
- 总高度 = 内容区域高度 + 上下边框 + 上下内边距 + 上下外边距



怪异盒模型的元素宽度和高度由**内容区域，边框**两个部分组成。

怪异盒宽度和高度计算公式：

- 总宽度 = 内容区域宽度 + 左右边框
- 总高度 = 内容区域高度 + 上下边框



## 2、伪类和伪元素的区别是什么？

伪类是用来选择处于特定状态的元素，比如`:hover`，`:active`等。

伪元素是用来创造虚构的元素，比如`::before`，`::after`等。

伪类不会创造新的元素，而伪元素会。

伪类以单冒号(:)开头，而伪元素以双冒号(::)开头。



## 3、CSS如何实现居中布局？

水平居中：

- 行内元素居中：
  - 父元素设置`text-align:center;`
- 块级元素居中：
  - 指定宽度后，设置`margin:0 auto;`

垂直居中：

- 行内元素居中：
  - 设置`line-height`与`height`相等。

- 块级元素居中：

  - 使用`flex`布局
  - 在已知高度的情况下：
    - 第一种：使用CSS3的新属性`calc`，计算`top`：`top: calc(50% - 50px)`
      - 请注意calc属性计算时运算符前后有空格。
    - 第二种：使用`top` + `margin-top`实现
  - 在未知高度的情况下：
  - 使用`margin-top:50%` + `transform:translateY(-50%)`
  



## 4、CSS的选择器有哪些？

- ID选择器 `#hello`
- 类选择器 `.container`
- 标签选择器 `div`
- 后代选择器 `h1 p`
- 相邻后代选择器 `h1>p`
- 兄弟选择器 `li~a`
- 相邻兄弟选择器 `li+a`
- 属性选择器 `input[type="text"]`
- 伪类选择器 `a:hover`
- 伪元素选择器 `::before`
- 通配符选择器 `*`



## 5、CSS优先级如何计算？

CSS优先级计算是指多个CSS声明作用于同一个元素时，如何确定哪个声明的效果最终生效。

CSS优先级计算的基本原则是：

- 优先级由选择器的类型和数量决定，一般来说，内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 > 通配符选择器。
- 优先级可以用四个数字（a,b,c,d）表示，其中a表示内联样式的个数，b表示ID选择器的个数，c表示类选择器、属性选择器和伪类选择器的个数之和，d表示标签选择器和伪元素选择器的个数之和。比较优先级时，按照a,b,c,d的顺序依次比较，大的则优先级高，相等则比较下一个。
- 如果两个声明的优先级相同，则后出现的声明会覆盖前面的声明。
- 如果一个声明中使用了 `!important` 标志，则该声明的优先级最高，除非另一个声明也使用了 `!important` 并且优先级更高或者出现在后面。
- 优先级只与选择器有关，与选择器在文档的位置或者样式表中的位置无关。

举例：

```html
<style>
  <!-- 权重：0101 -->
  <!-- 权重最高 -->
  #container p {
    color: red;
  }
  <!-- 权重：0010 -->
  .box {
    color: green;
  }
  <!-- 权重：0001 -->
  p {
    color: blue !important;
  }
</style>
<div id="container">
  <p class="box">Hello</p>
</div>
```



## 6、长度单位px，em和rem的区别是什么？

px时相对于屏幕分辨率的长度单位。px的有点是精确和一致，缺点是不灵活，不能自适应不同设备的屏幕尺寸和分辨率。

em是相对于当前元素的字体大小的长度单位，1em等于当前元素的`font-size`。如果当前元素没有设置`font-size`，则会继承父元素的`font-size`。em的优点是可以实现元素内部的缩放效果，缺点是计算复杂，容易受到父元素的影响。

rem是相对于根元素(html)的字体大小的长度单位，1rem等于html元素的`font-size`。如果html元素没有设置`font-size`，则会使用浏览器的默认字体大小(通常是16px)。rem的优点是可以实现整个页面的缩放效果，且计算简单，不受父元素的影响，缺点是兼容性不如px和em。



## 7、讲一下flex弹性盒布局？

1. 概念和优势
   - flex布局是一种用于按行或列布局元素的一维布局方法，它可以为盒状模型提供最大的灵活性，可以方便地实现各种对齐、分布、缩放等效果。
2. 核心属性
   - flex布局主要有以下几个属性：
     - `display`用于指定一个容器为flex布局
     - `flex-direction`用于指定主轴的方向
     - `justify-content`用于指定主轴的对齐方式
     - `align-items`用于指定交叉轴的对齐方式
     - `flex-wrap`用于指定是否换行
3. 总结flex布局的特点和优缺点
   - 总之，flex布局是一种非常灵活和强大的布局方法，它可以适应不同的屏幕尺寸和设备，也可以简化很多复杂的布局问题。但是，它也有一些缺点，比如兼容性问题，需要使用浏览器前缀或者polyfill来支持老旧的浏览器；还有性能问题，如果项目过多或者嵌套过深，可能会影响渲染速度和内存消耗。



## 8、浮动塌陷问题的解决方法是什么？

1. 介绍浮动塌陷的概念和原因
   - 浮动塌陷是指当一个容器的子元素浮动后，导致容器的高度丢失或者缩小，从而影响布局的现象。这是因为浮动元素脱离了文档流，不占据容器的空间，而容器的高度默认是由子元素撑开的。
2. 列举浮动塌陷的几种解决方法
   - 给容器设置固定的高度，这样就不依赖子元素的高度了。但这样做需要知道容器的精确高度，而且不利于响应式布局。
   - 给容器设置`overflow`属性为`hidden`或者`auto`，这样可以触发BFC(块级格式化上下文)，让容器包含浮动元素。但这样做可能会导致内容溢出或者出现滚动条。
   - 给容器添加一个空元素，并给它设置`clear`属性为`both`，这样就可以清除浮动，让容器恢复正常高度。但这样做需要增加额外的标签和样式。
   - 使用**伪元素**在容器的最后添加一个**内容为空**的**块级元素**，并给它设置`clean`属性为`both`，这样也可以清除浮动，而且不需要增加额外的标签和样式。



## 9、讲一下position的属性值的含义？

1. 介绍`position`属性的概念和作用
   - `postion`是CSS中用来控制元素定位方式的一个属性，它可以让元素按照文档流或者相对于其他元素进行偏移或者固定。
2. 列举`position`属性
   - `postion`由5个值，分别是`static`、`relative`、`absolute`、`fixed`和`sticky`，它们决定了元素是按照文档流还是脱离文档流进行定位，以及相对于哪个参考点进行偏移或者固定。
     - `static`是默认值，表示元素按照文档流进行定位，不受其他定位属性的影响。
     - `relative`表示元素按照文档流进行定位，然后相对于自身进行偏移，偏移不会影响其他元素的位置。
     - `absolute`表示元素脱离文档流，相对于最近的定位祖先元素或者初始包含块进行定位，元素的位置由其他定位属性确定。
     - `fixed`表示元素脱离文档流，相对于视口进行定位，元素的位置由其他定位属性确定，元素在页面滚动时不会改变位置。
     - `sticky`表示元素按照文档流进行定位，然后在其最近滚动祖先和其包含块之间切换相对定位和固定定位，实现“粘性”效果。



## 10、position:fixed一定是相对于浏览器窗口进行定位吗？

1. 介绍`position:fiexd`

   - `position:fiexd`通常是相对于浏览器窗口进行定位的，这意味着它不随滚动条滚动，而是始终保持在某个位置不动。

2. 说明`position:fiexd`属性的特殊规则

   - 但是，如果`position:fixed`元素的祖先元素具有某些CSS属性，那么`position:fixed`元素就不再相对于浏览器窗口进行定位，而是相对于祖先元素进行定位。这些属性包括`transform`、filter、perspective、contain、mix-blend-mode等。

3. 总结

   - 这些CSS属性会使祖先元素成为`position:fixed`元素的包含块，也就是`position:fixed`元素的定位参考点。这样`position:fixed`元素就会随着祖先元素的滚动而滚动，并且受到祖先元素的大小和位置的影响。

4. 示例代码

   ```html
   <html>
       <head>
           <style>
               * {
                   margin: 0;
                   padding: 0;
                   box-sizing: border-box;
               }
   
               .container {
                   height: 2000px;
               }
   
               #b1 {
                   height: 400px;
                   background-color: aqua;
               }
   
               #b2 {
                   height: 800px;
                   background-color: red;
                   /* 切换这个属性即可验证 */
                   transform: scale(1);
               }
   
               .ad {
                   position: fixed;
                   top: 50%;
                   transform: translateY(-50%);
                   width: 200px;
                   height: 300px;
                   background-color: #73ad21;
               }
           </style>
       </head>
       <body>
           <div class="container">
               <div id="b1"></div>
               <div id="b2">
                   <div class="ad"></div>
               </div>
           </div>
       </body>
   </html>
   ```



## 11、BFC和IFC？

BFC和IFC是CSS布局中的两种格式化上下文，它们是一种独立的渲染区域，有自己的布局规则，可以与其他格式化上下文相互隔离。

BFC是块级格式化上下文，它是由块级盒子组成的 ，比如`div p ul`等元素。BFC的布局规则如下：

- BFC中的元素按照垂直方向从上到下排列，相邻元素的外边距会发生重叠。
- BFC中的元素不会影响或者被影响到外部的元素，也就是说BFC是一个独立的容器。
- BFC的宽度由包含块的宽度和浮动元素决定，也就是说BFC可以包含浮动元素，并防止浮动元素溢出。
- BFC可以组织元素被父元素的边距折叠。

BFC可以通过以下方式触发：

- 根元素（整个页面就是一个大的BFC）
- float 为 left | right
- overflow 为 hidden | auto | scroll
- display 为 inline-block | table-cell | table-caption | flex | inline-flex
- position 为 absolute | fixed

BFC的功能：

- 解决margin塌陷
- 清除浮动
- 防止普通文档流被浮动元素遮挡

IFC是行内格式化上下文，它是由行内盒子组成的，比如`span a img`等元素，IFC的布局规则如下：

- IFC中的元素按照水平方向从左到右排列，相邻元素的外边距不会发生重叠。
- IFC中的元素会根据垂直对齐方式（vertical-align）进行对齐，可以是顶部对齐、底部对齐、居中对齐等。
- IFC中的元素不会影响或者被影响到外部的元素，也就是说IFC是一个独立的容器。
- ICC的高度由包含块的高度和行框决定，也就是说IFC可以包含多行文本，并根据行高进行换行。

IFC可以通过以下方式触发：

- display 为 inline | inline-block



题外内容：

[深度剖析Margin塌陷，BFC，Containing Block之间的关系](https://zhuanlan.zhihu.com/p/30168984)



# Vue

## 1、讲一下computed和watch的区别？

1. 介绍概念和作用
   - `computed`是计算属性，用来根据现有的属性计算出一个新的属性。
   - `watch`是监听，用来监听`data`中的数据变化，并执行相应的回调函数。
2. 列举核心区别
   - `computed`支持缓存，当其依赖的属性没有发生变化时，计算属性会从缓存中读取，而不会重新计算；`watch`不支持缓存，当监听的属性发生变化时，每次都会执行回调函数。
   - `computed`适用于根据其他属性的变化而变化的场景，比如购物车商品结算；`watch`适用于根据数据变化而执行异步操作或开销较大的操作的场景，比如搜索框根据关键词发送请求。
   - `computed`只能返回一个值，不能执行其他操作；`watch`可以返回任意值或执行任意操作。
   - `computed`默认只有`getter`方法，如果需要`setter`方法，需要手动设置；`watch`默认有`handler`方法，可以设置`deep`、`immediate`等选项。



## 2、v-if和v-show的区别？

1. 介绍概念和作用
   - `v-if`和`v-show`都是Vue中的指令，用来控制元素的显示和隐藏。
2. 列举核心区别
   - `v-if`是根据条件来动态地增加或删除DOM元素，只有当条件为真时才会渲染元素；`v-show`是根据条件来动态地显示或隐藏元素，无论条件是否为真，元素都会被渲染，只是通过CSS的`display`属性来控制显隐。
   - `v-if`有更高的切换开销，因为每次切换都会触发元素的销毁和重建；`v-show`有更高的初始渲染开销，因为无论条件是否为真，元素都会被渲染。
   - `v-if`支持`template`标签，可以在一个条件块中包含多个元素；`v-show`不支持`template`标签，只能作用于单个元素。
   - `v-if`搭配`v-else`可以实现多分支的条件渲染；`v-show`没有类似指令，只能实现单分支的条件渲染。



## 3、Vue常用指令？

Vue指令是指在Vue模板中使用的一些特殊的属性，以`v-`开头，用于实现一些动态的功能。Vue常用指令有以下几种：

- **v-bind**：用于动态地绑定一个或多个属性，或一个组件的`prop`，可以缩写为冒号(:)。
- **v-on**：用于在元素上监听事件，可以缩写为@。
- **v-model**：用于在表单控件或组件上创建双向数据绑定。
- **v-if**：用于根据表达式的真假值，来条件性地渲染元素或模板片段。
- **v-show**：用于根据表达式的真假值，来切换元素的显示和隐藏。
- **v-for**：用于基于原始数据多次渲染元素。
- **v-slot**：用于向组件传递内容，可以缩写为#。
- **v-pre**：用于跳过该元素和子元素的编译过程，直接显示原始的Mustache标签。
- **v-cloak**：用于在Vue实例结束编译之前一直保持在元素上，可以配合CSS规则`[v-cloak]{display:none}`来隐藏未编译的Mustache标签，避免闪烁现象。
- **v-once**：用于只渲染一次元素和组件，不会随着数据的改变而更新。



## 4、Vue父子组件挂载顺序？

Vue父子组件挂载顺序是指在Vue组件渲染和更新的过程中，父组件和子组件的`mounted`生命周期钩子函数的执行顺序。`mounted`生命周期钩子函数是在组件被挂载到DOM后调用的，通常用于执行一些依赖于DOM的操作。

Vue父子组件挂载顺序的一般规律是：父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。也就是说，父组件的`mounted`生命周期钩子函数会在所有子组件的`mounted`生命周期钩子函数之后调用。这样可以保证父组件可以访问到完整的DOM结构，包括所有子组件的DOM元素。



题外内容：

```markdown
# 加载渲染过程
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

# 更新过程
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

# 销毁过程
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
```



## 5、v-model的作用？

`v-model`的作用是在表单元素和数据之间建立双向绑定，让数据的变化能够实时反映在视图上，也让用户的输入能够自动更新到数据中。

`v-model`的实现原理是通过`v-bind`绑定一个value属性，用来接收数据，并通过`v-on`绑定一个input事件，用来监听用户输入并更新数据。例如：

```
<input type="text" v-model="msg">
相当于
<input type="text" :value="msg"@input="msg=$event.target.value">
```

`v-model`还可以根据不同的表单元素类型，使用不同的属性和事件，比如`radio、checkbox、select`等，并且支持一些修饰符，比如`.lazy、.number、.trim`等，来实现更灵活的双向绑定。



## 6、v-for和v-if放在一起用好吗？

`v-for` 和 `v-if` 放在一起用不好。

在Vue2中，`v-for` 比 `v-if` 优先级高，这意味着如果同时使用 `v-for` 和 `v-if`，`v-if` 会在每个 `v-for` 循环中执行，可能会导致性能损失。如果目的是有条件地跳过循环的执行，那么可以将 `v-if` 放置于外层元素（或<template>）上。如：

```vue
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
```

在Vue3中，`v-if` 比 `v-for` 的优先级更高，这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名。这种情况可以在外层新包装一层 `<template>` 再在其上使用 `v-for` 就可以解决这个问题。如：

```vue
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

除了嵌套元素这种解决方法外，Vue官方也推荐使用计算属性来解决以上问题。使用计算属性来过滤出需要显示的列表项，然后在模板中只使用 `v-for`。



题外内容：

[Vue2的官方解释](https://v2.cn.vuejs.org/v2/guide/list.html#v-for-object)

[Vue3的官方解释](https://cn.vuejs.org/guide/essentials/list.html#v-for-with-v-if)



## 7、Vue组件样式污染？

Vue组件样式污染是指一个组件的样式影响到了另一个组件的样式，导致页面显示不正确或不一致的问题。这个问题通常发生在使用全局样式或者相同的类名时。

最常用的是使用 `scoped` 属性。`scoped` 属性可以让组件的样式只作用于当前组件，而不会影响其他组件。这是通过给每个组件添加一个唯一的属性，然后在样式中使用属性选择器来实现的。



## 8、Vue如何给一个对象添加新的属性？

这个问题涉及到Vue的数据响应式原理。Vue的数据响应式原理是基于 `Object.defineProperty()` 方法，它可以把对象的属性转换为 `getter` 和 `setter`，从而实现对数据的监听和更新。但是，这个方法有一个限制，就是它不能检测到对象属性的添加和删除。也就是说，如果在这个实例创建之后给对象添加新的属性，这个属性不会被Vue转换为响应式的，也不会触发视图更新。

为了解决这个问题，Vue提供了两种方法来给对象添加新的响应式属性：

1. `Vue.set(object,key,value)` 或 `vm.$set(object.key,value)`：这两个方法是等价的，它们个可以在对象上添加一个新的属性，并且让这个属性变成响应式的，同时触发视图更新。这个方法适合给对象添加少量的新属性。
2. `Object.assign(target,source)`：这个方法可以创建一个新的对象，并且把源对象和新添加的属性合并到一起。这样，新对象就会拥有源对象的所有响应式属性和新添加的属性。然后，把新对象赋值给原来的变量，就可以实现视图更新。这个方法适合给对象添加多个新属性。



## 9、讲一下vue的keep-alive组件？什么时候会用到？

`keep-alive` 是Vue的一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例，从而避免重复渲染和销毁组件，提供性能和用户体验。

`keep-alive` 组件有两个常用的prop属性：`include` 和 `exclude`，它们可以用来定制那些组件需要被缓存，哪些不需要。这两个属性的值可以是一个字符串、一个正则表达式或者一个数组，它们会根据组件的 `name` 选项进行匹配。

`keep-alive` 组件还有一个 `max` 属性，可以用来限制可被缓存的最大组件实例数。当缓存的实例数量超过指定的最大书香时，最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。

当一个组件被 `keep-alive` 缓存时，它的生命周期会发生变化。它不会被卸载，而是变成不活跃状态。当它再次被激活时，它会重新渲染。为了处理这个情况，Vue提供了两个特殊的生命周期钩子函数：`activated` 和 `deactivated`。它们分别在组件被激活和被停用时调用。我们可以在这两个钩子中执行一些逻辑，比如获取数据、清除定时器等。

那么什么时候会用到 `keep-alive` 组件呢？一般来说，当我们需要在多个组件间频繁切换，并且希望保留组件的状态或避免重新请求数据时，就可以使用 `keep-alive` 组件。比如，在一个列表页和详情页之间切换，我们可能希望列表页能够保留滚动位置、筛选条件等状态，并且不需要每次都重新加载数据，就可以使用 `keep-alive` 组件，可以提高性能和用户体验。



## 10、process.nextTick和Vue.nextTick的区别？

`process.nextTick` 是Node.js中的一个方法，它可以在当前执行栈的尾部（同步代码执行完毕）添加一个回调函数，让它在下一个事件循环的开始（异步代码执行之前）执行。它相当于把一个任务放到了微任务队列中，优先于其他异步任务执行。

`Vue.nextTick` 是Vue中的一个方法，它可以在下次DOM更新循环结束之后执行一个延迟回调。它相当于把一个任务放到了宏任务队列中，等待当前的微任务队列和DOM更新完成后执行。

它们的区别主要有以下几点：

- 它们属于不同的运行环境，`process.nextTick` 是Node.js中的方法，而 `Vue.nextTick` 是Vue中的方法。在浏览器中，没有 `process` 对象，也就没有 `process.nextTick` 方法。
- 它们执行的时机不同，`process.nextTick` 会在当前执行栈的尾部执行，而 `Vue.nextTick` 会在下次DOM更新循环结束后执行。这意味着 `process.nextTick` 会比 `Vue.nextTick` 更早执行。
- 它们使用的场景不同，`process.nextTick` 一般用于处理异步流程中的同步任务，比如 `Promise` 的 `then ` 方法或 `async/await` 语法。`Vue.nextTick` 一般用于处理数据变化后DOM还未及时更新的问题，比如获取数据更新后最新DOM的变化或避免重复操作DOM。



## 11、watch中deep和immediate的作用？

deep：表示是否深度监听，如果为true，那么可以监听对象或数组中每个属性的变化，而不仅仅是对象或数组本身的变化。这样就可以实现对复杂数据类型的检测，但是性能开销会比较大。

immediate：表示是否立即执行监听函数，如果为true，那么在watch绑定时就会执行一次监听函数，而不用等到数据变化时才执行。这样可以实现对初始数据的处理，但是可能会导致多余的执行。



## 12、讲解slot？有什么作用？

slot是Vue中的一种内容分发的机制，可以让父组件在子组件的模板中插入内容。

slot有以下几种作用：

- slot可以让组件更加灵活和可复用，可以实现内容和样式的分离。
- slot可以让父组件根据不同的场景传入不同的内容，而不需要修改子组件的模板。
- slot可以让子组件提供多个插槽出口，让父组件可以在不同的位置插入内容。
- slot可以让子组件向父组件传递一些属性，也就是插槽prop，让父组件可以在插槽中访问子组件的数据。



## 13、vue如何实现自定义指令？

Vue可以通过两种方式实现自定义指令：全局指令和局部指令。

Vue2中通过 `Vue.directive()` 函数注册一个全局指令；局部指令是通过组件的 `directives` 属性，只能在该组件中使用。

Vue3中通过应用实例 `app.directive()` 函数注册一个全局指令；局部指令的创建有两种情况：

- 在 `<script setup>` 语法中，任何以 `v` 开头的**驼峰式命名**的变量都可以被用作一个自定义指令。
- 在没有使用 `script setup` 语法的情况下，自定义指令需要通过 `directives` 选项注册。

一个指令的定义对象可以提供几种钩子函数，都是可选的：

```javascript
const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {},
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {}
}
```

钩子参数：

`el`：指令绑定道的元素。这可以用于直接操作DOM。

`binding`：一个对象，包含传递给指令的值，参数等。

`vnode`：代表绑定元素的底层VNode。

`prevNode`：之前的渲染中代表指令所绑定元素的VNode。仅在 `beforeUpdate` 和 `updated` 钩子中可用。



当在组件上使用自定义指令时，它会始终应用到组件的根节点。如果组件有多个根节点，那么指令将会被忽略并抛出一个警告。



官方贴士：

1. 只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 `v-bind` 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。
2. 不推荐在组件上使用自定义指令。



题外内容：

[Vue2官方链接：自定义指令](https://v2.cn.vuejs.org/v2/guide/custom-directive.html)

[Vue3官方链接：自定义指令](https://cn.vuejs.org/guide/reusability/custom-directives.html#introduction)



## 14、use方法的使用？

`use()` 方法的作用是安装一个插件。插件是一种能为Vue添加全局功能的工具代码。

`use()` 方法可以传递两个参数，第一个参数是插件本身，可选的第二个参数是要传递给插件的配置选项。

插件可以是一个带 `install()` 方法的对象；或者是一个将被用作 `install()` 方法的函数。插件选项将会传递给插件的 `install()` 方法。

如果 `use()` 方法对同一个插件多次调用，该插件只会被安装一次。



题外内容：

[Vue3官方链接：app.use()](https://cn.vuejs.org/api/application.html#app-use)

[Vue3官方链接：插件](https://cn.vuejs.org/guide/reusability/plugins.html)



## 15、Vue和React的区别是什么？(待完善)

1. 响应式原理不同
2. 监听数据变化的实现原理不同
3. 组件写法不同
4. Diff算法不同
5. 核心思想不同
6. 数据流不同
7. 组合不同功能的方式不同（mixin和HoC)
8. 组件通信方法不同
9. 模板渲染方式不同
10. 渲染过程不同
11. 框架本质不同



题外内容：

[Vue和React的区别到底是什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/7071889478305972255#heading-13)

[浅谈React 虚拟DOM，Diff算法与Key机制 - 掘金 (juejin.cn)](https://juejin.cn/post/6967626390380216334#heading-1)



## 16、Vue父子组件如何通信？兄弟组件如何通信？

父子组件通信：

- 父组件通过 `props` 向子组件传递数据，子组件通过 `$emit` 触发事件向父组件传递数据。这是最基本的通信方式，也是单向数据流的体现。`props` 是单向绑定的，不能在子组件中修改，否则会报错。`$emit` 可以携带参数，也可以自定义事件名。
- 父组件通过 `$refs` 访问子组件的属性和方法，子组件通过 `$parent` 或 `$root` 访问父组件或根组件的属性和方法。这是一种直接操作组件实例的方式，不推荐过度使用，因为会破会组件的封装性和复用性。
- 父组件通过 `provide` 提供数据或方法，子组件通过 `inject` 接收数据或方法。这是一种跨级通信的方式，可以避免多层嵌套 `props` 传递。`provide` 和 `inject` 不受层级限制，只要在祖先组件中提供了数据或方法，后代组件都可以注入使用。

兄弟组件通信：

- 通过共同的父组件作为中介，父组件监听一个子组件的事件，并修改另一个子组件的 `props` 。这是一种简单的方式，但是如果兄弟组件较多或者层级较深，就会比较麻烦。
- 通过事件总线（Event Bus）进行通信。事件总线是一个Vue实例，用来在任意两个组件之间传递事件和数据。可以在全局或者局部注册事件总线，并在需要通信的组件中使用 `$on` 监听事件和 `$emit` 触发事件。
- 通过Vuex进行通信。Vuex是一个专为Vue应用开发的状态管理模式，它提供了一个全局的store来存储应用的状态，并通过一些规则保证状态的可预测性。任何组件都可以从store中获取状态，并通过提交 `mutation` 或者派发 `action` 来改变状态。



题外内容：

[Vue3官方链接： 依赖注入](https://cn.vuejs.org/guide/components/provide-inject.html)



## 17、Vue中的Event Bus

**Vue中Event Bus的原理？**

Event Bus的原理是利用一个全局的事件总线，也就是一个中央事件管理器，让组件之间通过事件来通信，通过 `$emit()` 方法触发事件，再通过 `$on()` 方法监听该事件，从而实现组件间的状态共享。

**Vue中Event Bus是什么模式？发布者订阅者分别是做什么的？**

Event Bus基于发布订阅模式。发布订阅模式是一种广泛应用于组件间通信的模式，它基于一个中央事件管理器，即发布者。发布者负责发布事件，而订阅者则订阅并接收事件，从而实现组件间通信。

在Vue中，发布者就是通过 `$emit()` 方法触发事件的组件，而订阅者则通过 `$on()` 方法监听该事件。

**Vue中怎么实现Event Bus？**

只需要创建一个全局的Vue实例作为消息中心，并在需要的组件中使用 `$emit $on $off` 方法就好了。



## 18、Vue、React和JQuery在不同场景下怎么选型？

Vue、React和JQuery是三种不同的前端开发框架，它们各有优缺点，适用于不同的场景。

- JQuery是一个轻量级的JavaScript库，它可以兼容各种浏览器，提供了丰富的插件和动画效果。但是JQuery的体积较大，不适合流量限制较大的项目，也不适合移动端项目。而且JQuery是直接操作原生DOM，性能上也较差。因此，JQuery比较适合用来搭建没有什么交互行为的项目。
- Vue和React都是基于MVVM模式的前端框架，它们使用了虚拟DOM技术，避免了页面多次回流重绘的问题。它们也都实现了组件化，提高了代码的复用性和可维护性。它们都有自己的构建工具和调试工具，方便开发者快速搭建和调试项目。
- React和Vue的主要区别在于模板语法和数据流管理。React使用JSX语法，在JavaScript中嵌入HTML代码，这样可以让开发者更灵活地控制UI逻辑。Vue使用静态模板语法，将DOM和状态绑定在一起，这样可以让开发者更直观地看到UI结构。

React和Vue都是非常优秀的前端框架，它们之间没有绝对的优劣之分。具体使用什么框架取决于开发团队的熟练程度和项目需求。



## 19、Vue和JQuery的区别是什么？为什么JQuery被淘汰了？

**Vue和JQuery的区别是什么？**

- Vue和JQuery的主要区别在于它们的开发思路和范式。Vue是一种声明式编程语言，它通过数据驱动视图的方式来实现界面更新，不需要直接操作DOM元素。JQuery是一种命令式编程语言，它通过选择器获取DOM元素，并对其进行修改或添加事件监听来实现界面更新。
- Vue和JQuery的另一个区别在于它们的性能和优化方式。Vue使用虚拟DOM来提高渲染性能，它可以对静态的虚拟DOM节点进行优化，在数据变化时只更新相关的组件，避免不必要的渲染和diff操作。Vue提供了一些优化手段，比如computed，watch，异步组件等。JQuery也提供了一些优化手段，比如缓存选择器，使用事件委托，减少回流重绘等。

**为什么JQuery被淘汰了？**

- JQuery出现的目的是为了解决浏览器兼容性问题和简化DOM操作。但是随着HTML5规范的普及和浏览器厂商的同意遵循，浏览器兼容性问题已经不再是一个大问题。而且原生的JavaScript也提供了很多方便的API来操作DOM元素，比如 `querySelector addEventListener classList` 等。
- JQuery的设计理念已经过时，它不能适应现代的前端开发和趋势。随着单页应用的兴起和流行，前端开发需要更多的功能和特性，比如双向绑定，组件化，路由管理，状态管理等。JQuery作为一个DOM操作库，不能提供这些功能和特性，而需要依赖其他的框架或库来实现。而Vue作为一个前端框架，可以提供这些功能和特性，而且可以和其他插件和库很好地集成，形成一个完整的前端解决方案。
- 随着ES6 / ES7 / ES8 等新的JavaScript标准的出现和实现，前端开发可以使用更多的语法糖和新特性，比如箭头函数，模板字符串，解构赋值，Promise，async / await等。JQuery作为一个基于ES5的库，不能充分利用这些新特性。而Vue作为一个基于ES6+的框架，可以充分利用这些新特性。



## 20、computed和method的区别？

`computed` 和 `method` 是Vue中两种不同的定义函数的方式，它们有以下区别：

- **调用方式不同。**`computed` 定义的函数是以属性的形式访问的，不需要加括号，比如 {{ getFullName }}。`method` 定义的函数则需要加括号来调用，比如 {{ getFullName () }}。
- **缓存机制不同。**`computed` 定义的函数会根据它所依赖的数据进行缓存，只有当依赖的数据发生变化时，才会重新计算。`method` 定义的函数则没有缓存机制，每次调用都会重新执行。
- **适用场景不同。**`computed` 适用于根据一些数据计算出另一些数据的场景，比如根据姓名计算出全名，根据商品数量和单价计算出总价等。`method` 适用于执行一些具体的操作或逻辑的场景，比如发送请求，改变状态，触发事件等。



## 21、Vue的生命周期

**什么是生命周期钩子函数？**

Vue生命周期钩子是一些特殊的函数，它们会在组件的不同阶段被自动调用，让我们可以在合适的时机执行一些自定义的逻辑。

Vue生命周期钩子大致可以分为以下几类：

- 创建阶段：这个阶段是组件实例被创建和初始化的过程，涉及到 `beforeCreate` 和 `created` 两个钩子。
- 挂载阶段：这个阶段是组件实例被挂载到DOM上并开始渲染的过程，涉及到 `beforeMount` 和 `mounted` 两个钩子。
- 更新阶段：这个阶段是组件实例根据响应式的变化而重新渲染的过程，涉及到 `beforeUpdate` 和 `updated` 两个钩子。
- 卸载阶段：这个阶段是组件实例被销毁和移除的过程，涉及到 `beforeDestory` 和 `destoryed` 两个钩子。

使用生命周期钩子的好处是可以让我们在模板中直接操作DOM元素或组件实例，而不需要通过其他方式来获取它们。这有助于我们实现一些特殊的功能，比如程序化地聚焦输入框，或者初始化一个第三方库在一个元素上。

**有哪些常用的生命周期钩子函数？一般会做哪些操作？**

- **created**：在组件实例被创建之后调用，此时组件的 `data、methods、computed、watch` 等选项已经被初始化，但是还没有挂载到DOM上，也没有开始编译模板。这个钩子一般用于执行一些响应式的初始化逻辑，比如获取数据、设置定时器等。
- **mounted**：在组件实例被挂载到DOM之后调用。此时组件已经完成了渲染，并且可以访问到真实的DOM元素。这个钩子一般用于执行一些与DOM相关的渲染后逻辑，比如操作DOM元素、初始化第三方库等。
- **beforeUpdate**：在组件实例根据新数据重新渲染之前调用，此时组件还没有开始更新虚拟DOM和真实DOM。这个钩子一般用于执行一些更新前的逻辑，比如重置数据或状态等。
- **updated**：在组件实例根据新数据重新渲染之后调用。此时组件已经完成了更新虚拟DOM和真实DOM。这个钩子一般用于执行一些更新后的逻辑，比如操作更新后的DOM元素，同步非响应式数据等。
- **beforeDestory**：在组件实例被卸载之前调用。此时组件还没有开始移除虚拟DOM和真实DOM。这个钩子一般用于执行一些卸载前的逻辑，比如移除事件监听器或定时器等。
- **destoryed**：在组件实例被卸载之后调用。此时组件已经完成了移除虚拟DOM和真实DOM，并且失去了响应式能力。这个钩子一般用于执行一些卸载后的逻辑，比如释放资源或内存等。

**Vue3新增加了哪些生命周期钩子函数？**

| Vue2          | Vue3              | 说明                                 |
| :------------ | :---------------- | :----------------------------------- |
| beforeCreate  | -                 | 在组件实例被创建之前调用             |
| created       | -                 | 在组件实例被创建之后调用             |
| beforeMount   | onBeforeMount     | 在组件实例被挂载到DOM之前调用        |
| mounted       | onMounted         | 在组件实例被挂载到DOM之后调用        |
| beforeUpdate  | onBeforeUpdate    | 在组件实例根据新数据重新渲染之前调用 |
| updated       | onUpdated         | 在组件实例根据新数据重新渲染之后调用 |
| beforeDestroy | onBeforeUnmount   | 在组件实例被卸载之前调用             |
| destroyed     | onUnmounted       | 在组件实例被卸载之后调用             |
| activated     | onActivated       | 在keep-alive组件被激活时调用         |
| deactivated   | onDeactivated     | 在keep-alive组件被停用时调用         |
| errorCaptured | onErrorCaptured   | 在捕获到一个来自子孙组件的错误时调用 |
| -             | onRenderTracked   | 在渲染函数被追踪时调用               |
| -             | onRenderTriggered | 在渲染函数被触发时调用               |

**Vue父子组件的生命周期钩子函数的先后顺序？**

- **创建阶段：先父后子。**父组件的 `beforeCreate` 和 `created` 钩子先于子组件的 `beforeCreate` 和 `created` 钩子执行。
- **挂载阶段：先子后父。**子组件的 `beforeMount` 和 `mounted` 钩子先于父组件的  `beforeMount` 和 `mounted` 钩子执行。
- **更新阶段：先父后子。**父组件的 `beforeUpdate` 和 `updated` 钩子先于子组件的beforeUpdate和updated钩子执行。
- **卸载阶段：先子后父。**子组件的 `beforeDestory` 和 `destoryed` 钩子先于父组件的 `beforeDestory` 和 `destoryed` 钩子执行。

**为什么每个阶段的先后顺序不同？**

- 创建阶段：先父后子，是因为父组件需要先初始化自己的状态和选项，然后才能创建子组件的实例，并将自己的状态和选项传递给子组件。
- 挂载阶段：先子后父，是因为父组件需要先将子组件的模板编译成虚拟DOM，然后才能将自己的模板编译成虚拟DOM，并将子组件的虚拟DOM插入到自己的虚拟DOM中。最后，再将整个虚拟DOM渲染到真实DOM上。
- 更新阶段：先父后子，是因为父组件需要先根据新数据更新自己的虚拟DOM，然后才能更新子组件的虚拟DOM，并将新的子组件的虚拟DOM替换到自己的虚拟DOM中。最后，再将整个虚拟DOM和旧的虚拟DOM进行对比，找出差异，并更新到真实DOM上。
- 卸载阶段：先子后父，是因为父组件需要先将子组件的虚拟DOM从自己的虚拟DOM中移除，然后才能移除自己的虚拟DOM。最后，再将整个虚拟DOM从真实DOM上移除，并销毁组件实例。



## 22、Vue组件中data为什么是函数?

主要是为了解决组件复用时的数据隔离问题。

因为在Vue中，组件时可以被多次创建和销毁的，如果组件的data是一个对象，那么所有的组件实例就会共享同一个data对象，这样就会导致数据的污染和混乱。

为了避免这个问题，Vue要求组件的data必须是一个函数，这样每个组件实例就会有自己独立的data对象，互不影响。这也符合了组件化开发的原则，让每个组件都有自己的状态和逻辑，提高了代码的可维护性和可复用性。